////////////////////////////////////////////////////////////////////////
// Class:       PixLArReco
// Module Type: producer
// File:        PixLArReco_module.cc
//
// Generated at Mon Dec 11 03:04:31 2017 by Hunter Sullivan using artmod
// from cetpkgsupport v1_10_02.
////////////////////////////////////////////////////////////////////////

#include "art/Framework/Core/EDProducer.h"
#include "art/Framework/Core/ModuleMacros.h"
#include "art/Framework/Principal/Event.h"
#include "art/Framework/Principal/Handle.h"
#include "art/Framework/Principal/Run.h"
#include "art/Framework/Principal/SubRun.h"
#include "art/Utilities/InputTag.h"
#include "fhiclcpp/ParameterSet.h"
#include "messagefacility/MessageLogger/MessageLogger.h"

#include <memory>

///INCLUDES FOR PIXEL RECO
#include "PixLArEvent.h"


class PixLArReco;

class PixLArReco : public art::EDProducer {
public:
  explicit PixLArReco(fhicl::ParameterSet const & p);
  // The destructor generated by the compiler is fine for classes
  // without bare pointers or other resource use.

  // Plugins should not be copied or assigned.
  PixLArReco(PixLArReco const &) = delete;
  PixLArReco(PixLArReco &&) = delete;
  PixLArReco & operator = (PixLArReco const &) = delete;
  PixLArReco & operator = (PixLArReco &&) = delete;

  // Required functions.
  void produce(art::Event & e) override;

  // Selected optional functions.
  void beginJob() override;
  void beginRun(art::Run & r) override;
  void beginSubRun(art::SubRun & sr) override;
  void endJob() override;
  void endRun(art::Run & r) override;
  void endSubRun(art::SubRun & sr) override;
  void reconfigure(fhicl::ParameterSet const & p);

private:

  std::string fCalDataModuleLabel;
  std::string fTriggerUtility;

  // List of variables that characterize the PCB
  unsigned NumberOfPixels;
  unsigned NumberOfROI;
  double PCBSideWidth;
  double PixelRegionWidth;
  double PixelRegionHeight;
  double PixelPitch;
  std::vector<unsigned> PixelCoordZ;
  std::vector<unsigned> PixelCoordY;
  std::vector<unsigned> ROICoordZ;
  std::vector<unsigned> ROICoordY;

  // List of parameters that parameterize reconstruction
  double discSigmaPixelLead;
  double discSigmaPixelPeak;
  double discAbsPixelPeak;
  double discSigmaPixelTrail;
  double discSigmaRoiPosLead;
  double discSigmaRoiPosPeak;
  double discAbsRoiPosPeak;
  double discSigmaRoiPosTrail;
  double discSigmaRoiNegLead;
  double discSigmaRoiNegPeak;
  double discAbsRoiNegPeak;
  double discSigmaRoiNegTrail;
  double discRange;

  // Objects for reconstruction
  std::vector< PixLArEvent > PixLArEvents;

  // Function to find 2d hits 
  void PixLArReco::find2dHits(
            const TH2S &t_histo,
            std::vector<Hit2d> &t_hits,
            std::multimap<unsigned, unsigned> &t_hitOrderLead,
            std::multimap<unsigned, unsigned> &t_hitOrderTrail,
            unsigned &t_nMissed,
            const bool t_bipolar,
            const double t_discSigmaPosLead,
            const double t_discSigmaPosPeak,
            const double t_discAbsPosPeak,
            const double t_discSigmaPosTrail,
            const double t_discSigmaNegLead,
            const double t_discSigmaNegPeak,
            const double t_discAbsNegPeak,
            const double t_discSigmaNegTrail);

  // Function to take 2d hits and time information to constuct 3d space point
  void PixLArReco::find3dHits(Event &t_event);

  // Function to build hit candidates 
  void PixLArReco::buildHitCandidates(Event &t_event);

      
};


PixLArReco::PixLArReco(fhicl::ParameterSet const & p)
{
  this->reconfigure(p);

  // Call appropriate produces<>() functions here.
}

void PixLArReco::reconfigure(fhicl::ParameterSet const & p)
{
  // Implementation of optional member function here.
  fCalDataModuleLabel = p.get< std::string  >("CalDataModuleLabel");
  fTriggerUtility     = p.get< std::string >("TriggerUtility");
 
  NumberOfPixels   = p.get< int >("NumberOfPixels");
  NumberOfROI      = p.get< int >("NumberOfROI");
  PCBSideWidth     = p.get< double >("PCBSideWidth");
  PixelRegionWidth = p.get< double >("PixelRegionWidth");
  PixelPitch       = p.get< double >("PixelPitch");
  PixelCoordZ      = p.get< std::vector<int> >("PixelCoordZ");
  if (PixelCoordZ.size() < NumberOfPixels) throw std::runtime_error("PixLArReco::reconfigure ERROR! Input PixelCoordZ vector size != NumberOfPixels"); 
  PixelCoordY      = p.get< std::vector<int> >("PixelCoordY");
  if (PixelCoordY.size() < NumberOfPixels) throw std::runtime_error("PixLArReco::reconfigure ERROR! Input PixelCoordZ vector size != NumberOfPixels");
  ROICoordZ        = p.get< std::vector<int> >("ROICoordZ");
  if (ROICoordZ.size() < NumberOfROI) throw std::runtime_error("PixLArReco::reconfigure ERROR! Input ROICoordZ vector size != NumberOfROI");
  ROICoordY        = p.get< std::vector<int> >("ROICoordY");
  if (ROICoordY.size() < NumberOfROI) throw std::runtime_error("PixLArReco::reconfigure ERROR! Input PixelCoordY vector size != NumberOfROI");
 
  discSigmaPixelLead    = p.get< double >("discSigmaPixelLead");
  discSigmaPixelPeak    = p.get< double >("discSigmaPixelPeak"); 
  discAbsPixelPeak      = p.get< double >("discAbsPixelPeak");      
  discSigmaPixelTrail   = p.get< double >("discSigmaPixelTrail");   
  discSigmaRoiPosLead   = p.get< double >("discSigmaRoiPosLead");
  discSigmaRoiPosPeak   = p.get< double >("discSigmaRoiPosPeak");   
  discAbsRoiPosPeak     = p.get< double >("discAbsRoiPosPeak");     
  discSigmaRoiPosTrail  = p.get< double >("discSigmaRoiPosTrail");  
  discSigmaRoiNegLead   = p.get< double >("discSigmaRoiNegLead");   
  discSigmaRoiNegPeak   = p.get< double >("discSigmaRoiNegPeak");   
  discAbsRoiNegPeak     = p.get< double >("discAbsRoiNegPeak");     
  discSigmaRoiNegTrail  = p.get< double >("discSigmaRoiNegTrail");  
  discRange             = p.get< double >("discRange");

  // Read in the channel mapping
  // Will help matching raw data to pixels and ROI
  std::multimap< unsigned, std::pair<std::string, unsigned> > lariatChannelToPCB; // ( lariatChannel, (type, ID) )  type: pixel or ROI
  
  std::string filename = "PixLArChannelMapping.txt";
  std::ifstream mappingFile(filename.c_str());
  if (!mappingFile) {
	throw std::runtime_error("PixLArReco::reconfigure ERROR! Cannot open channel mapping file.");
  } else {

	std::string line;
        std::stringstream linestream(line);
       	std::string s1;
        std::string s2;

        std::getline(linestream, s1, ' ');
        std::getline(linestream, s2);
	
	while (!mappingFile.eof()) {
		
		if (s2 == "Channel") {
			// Mark which pcb we're mapping
			std::string pcb = s1;;
			
			if (s1 == "SideB") {
				pcb = "upstream";
			} else {
				if (s1 == "SideA") {
					pcb = "downstream";
				} else throw std::runtime_error("PixLArReco::reconfigure ERROR! Cannot identify PCB.");
			}
			
			// Read until next "channel" is read
			std::getline(linestream, s1, ' ');
			std::getline(linestream, s2);
			while (s2 != "Channel") {
				
				// Found lariat channel
				unsigned lariatChannel = s2;

				///Identify if this is a pixel or ROI
				if ( s1.at(0) == 'P') {
					// This is a pixel
					std::string type = "pixel";
                                        
					// Delete the P-R identifier
                                        s1.erase(0);

                                        if (pcb == "downstream") {
                                        	// Origin of PCB coordinate is downstream, top left pixel
                                               unsigned  pixelID = static_cast<unsigned>(s1);
					} else {
						// Have to add 120 to pixelID
                                                unsigned pixelID = 120 + static_cast<unsigned>(s1);
					}
                                        
					// Store info in ChannelToPCB Map             
                                        std::pair< std::string, unsigned > p;
                                        p = std::make_pair( type, pixelID );
                                        ChannelToPCB.insert( std::pair< unsigned, std::pair< std::string, unsigned> >( lariatChannel, p ) );
				} else {
					if ( s1.at(0) == 'R') {
						// This is a ROI
                                        	std::string type = "ROI";
                                         	
						// Delete the P-R identifier
                                                s1.erase(0);

						// Store info in ChannelToPCB Map
                                       		std::pair< std::string, unsigned > p;
                                        	p = std::make_pair( type, pixelID );
                                        	ChannelToPCB.insert( std::pair< unsigned, std::pair< std::string, unsigned> >( lariatChannel, p ) );

					} else throw std::runtime_error("PixLArReco::reconfigure ERROR! Cannot identify pixel or ROI.");
				}
				// Grab next line
				std::getline(linestream, s1, ' ');
                        	std::getline(linestream, s2);				
			}
		}
	}
  }
}

void PixLArReco::produce(art::Event & e)
{

  // Make a collection of Wires
  std::unique_ptr<std::vector<recob::Wire> > wirecol(new std::vector<recob::Wire>);
  // ... and an association set
  std::unique_ptr<art::Assns<raw::RawDigit,recob::Wire> > WireDigitAssn
 	(new art::Assns<raw::RawDigit,recob::Wire>);

  // Read in the digit List object(s). 
  art::Handle< std::vector<raw::RawDigit> > digitVecHandle;
  evt.getByLabel(fDigitModuleLabel, fSpillName, digitVecHandle);

  // JUST GOING TO WRITE SUDO CODE FOR THE TIME BEING 
  // Access to a pair of histos containing the pixel (first) and the ROI (second) data.
  // Take data and filter out common mode noise
  for (each event 2D histo) {
	NoiseFilter(histo);
  }

  // Hit Finder
  PixLArEvents.clear();
  PixLArEvents.resize(rawHistos.size());

  // Raw data vector const iterator. Read the raw data from there event by event.
  auto eventData = m_chargeData.getReadoutHistos().cbegin();
  
  // Events vector iterator. Will store the events built from the raw data in there.
  auto event = m_events.begin();
  
  // Loop over all events using the event IDs vector.
  for (const auto &eventId : m_chargeData.getEventIds()) {
  	std::cout << "Processing event number " << eventId << ":\n";
        std::cout << "Running 2D hit finder...\n";
        unsigned nMissedPixelHits = 0;
  	unsigned nMissedRoiHits = 0;
        // Find pixel hits.
        find2dHits(eventData->first,
        	event->pixelHits,
        	event->pixelHitOrderLead,
        	event->pixelHitOrderTrail,
        	nMissedPixelHits,
        	false,
        	discSigmaPixelLead,
        	discSigmaPixelPeak,
	        discAbsPixelPeak,
	        discSigmaPixelTrail,
	        0,
	        0,
	        0,
	        0);
  	std::cout << "Found " << event->pixelHits.size() << " pixel hits.\n";
  	std::cout << "Missed " << nMissedPixelHits << " pixel hits.\n";
  
 	// Find ROI hits.
	find2dHits(eventData->second,
		event->roiHits,
	  	event->roiHitOrderLead,
	  	event->roiHitOrderTrail,
		nMissedRoiHits,
		t_bipolarRoiHits,
	  	discSigmaRoiPosLead,
	        discSigmaRoiPosPeak,
	  	discAbsRoiPosPeak,
	  	discSigmaRoiPosTrail,
	  	discSigmaRoiNegLead,
	  	discSigmaRoiNegPeak,
	  	discAbsRoiNegPeak,
	  	discSigmaRoiNegTrail);
	  
	  std::cout << "Found " << event->roiHits.size() << " ROI hits.\n";
	  std::cout << "Missed " << nMissedRoiHits << " ROI hits.\n";
	  std::cout << "Running 3D hit finder...\n";
	  
	  // Search for matches between pixel and ROI 2D hits.
	  find3dHits(*event);
	  
	  // Build 3D hit candidates from the matches.
	  buildHitCandidates(*event);
	  
	  // Some statistics.
	  // Number of hit candidates for this event.
	  unsigned nHitCandidates = 0;
	  unsigned nAmbiguities = 0;
	 
	  // Number of pixel hits for this event that couldn't be matched to any ROI hits.
	  unsigned nUnmatchedPixelHits = 0;
	  
	  // Loop over all pixel hits using the pixel to ROI hit map.
	  for (const auto &hitCandidates : event->hitCandidates) {
	  	// Add number of ROI hit candidates for current pixel hit.
	  	nHitCandidates += hitCandidates.size();
	        
		// If there's no ROI hit candidates, increment the unmatched counter.
	        if (hitCandidates.empty()) {
	        	++nUnmatchedPixelHits;
	    		sizeOfHitCandidatesVec.push_back(0);
	        }
	        // If there's more than one ROI hit candidate, increment the ambiguity counter.
	        else {
	        	if (hitCandidates.size() > 1) {
	                	++nAmbiguities;
	       			sizeOfHitCandidatesVec.push_back(hitCandidates.size());
	       		} 
	     		else {
	     			sizeOfHitCandidatesVec.push_back(1);
	    		}
	  	}
	  }
	
	  std::cout << "Found " << nHitCandidates << " 3D hit candidates.\n";
	  std::cout << "Found " << nAmbiguities << " ambiguities.\n";
	  ambiguities.push_back(nAmbiguities);
	  std::cout << "Failed to match " << nUnmatchedPixelHits << " pixel hits.\n";
	  unmatched.push_back(nUnmatchedPixelHits);
	
	  // Store run, subrun and event ID to the event struct.
	  event->runId = getRunId();
	  event->subrunId = getSubrunId();
	  event->eventId = eventId;
	  
	  // Increment raw data and events vector iterators.
	  ++eventData;
	  ++event;
	}

	// Create histograms for ambiguities and unmatched pixels
        // Write to root file 
        TH1S Ambiguities("Ambiguities", "Ambiguities", ambiguities.size(), 0, ambiguities.size());
        Ambiguities.GetXaxis()->SetTitle("Event #");
        for(int i = 0; i < ambiguities.size(); i++) {
                Ambiguities.SetBinContent(i + 1, ambiguities.at(i));
        }
        TH1S Unmatched("Unmatched", "Unmatched", unmatched.size(), 0, unmatched.size());
        Unmatched.GetXaxis()->SetTitle("Event #");
        for(int i = 0; i < unmatched.size(); i++) {
                Unmatched.SetBinContent(i + 1, unmatched.at(i));
        }
        TH1S TimePeakAcceptance("TimePeakAcceptance", "Time Difference in Peaks", 100, -400, 400);
        TimePeakAcceptance.GetXaxis()->SetTitle("Samples (1 sample = 210 ns)");
        for(int i = 0; i < timePeakAcceptance.size(); i++) {
                TimePeakAcceptance.Fill(timePeakAcceptance.at(i));
        }
        TH1S TimeFirstSampleAcceptance("TimeFirstSampleAcceptance", "Time Difference in Rising Edge", 100, -400, 400);
        TimeFirstSampleAcceptance.GetXaxis()->SetTitle("Samples (1 sample = 210 ns)");
        for(int i = 0; i < timeFirstSampleAcceptance.size(); i++) {
                TimeFirstSampleAcceptance.Fill(timeFirstSampleAcceptance.at(i));
        }
        TH1S ROIMaxPulses("ROIMaxPulses", "ROI (Positive) Pulse Peaks", 100, 0, 800);
        ROIMaxPulses.GetXaxis()->SetTitle("ADC Value");
        for(int i = 0; i < posPulseROIMax.size(); i++) {
                ROIMaxPulses.Fill(posPulseROIMax.at(i));
        }
        TH1S PixelMaxPulses("PixelMaxPulses", "Pixel Pulse Peaks", 100, 0, 1500);
        PixelMaxPulses.GetXaxis()->SetTitle("ADC Value");
        for(int i = 0; i < posPulsePixelMax.size(); i++) {
                PixelMaxPulses.Fill(posPulsePixelMax.at(i));
        }
        TH1S ThresholdPosPixelPeaks("ThresholdPosPixelPeaks", "Threshold for Positive Pixel Peaks", 100, 0, 1500);
        ThresholdPosPixelPeaks.GetXaxis()->SetTitle("ADC Value");
        for(int i = 0; i < thrPosPeakVec.size(); i++) {
                ThresholdPosPixelPeaks.Fill(thrPosPeakVec.at(i));
        }
        TH1S Transparency("Transparency", "Transparency of Induction Grid", 100, 0, 140);
        Transparency.GetXaxis()->SetTitle("Transparency (%)");
        for(int i = 0; i < transparencyVec.size(); i++) {
                Transparency.Fill(transparencyVec.at(i));
        }
        TH1S PixelPulseWidths("PixelPulseWidths", "Pixel Pulse Widths", 100, 0, 300);
        PixelPulseWidths.GetXaxis()->SetTitle("Samples (1 sample = 210 ns)");
        for(int i = 0; i < pixelWidthsVec.size(); i++) {
                PixelPulseWidths.Fill(pixelWidthsVec.at(i));
        }
        TH1S ROIPulseWidths("ROIPulseWidths", "ROI Pulse Widths", 100, 0, 400);
        ROIPulseWidths.GetXaxis()->SetTitle("Samples (1 sample = 210 ns)");
        for(int i = 0; i < roiWidthsVec.size(); i++) {
                ROIPulseWidths.Fill(roiWidthsVec.at(i));
        }
        TH1S HitCandidates("HitCandidates", "Number of ROI Matches for a Pixel", 20, 0, 20);
        HitCandidates.GetXaxis()->SetTitle("Count");
        for(int i = 0; i < sizeOfHitCandidatesVec.size(); i++) {
                HitCandidates.Fill(sizeOfHitCandidatesVec.at(i));
        }

        TFile Results("../data/Results.root", "RECREATE");
        Ambiguities.Write();
        Unmatched.Write();
        TimePeakAcceptance.Write();
        TimeFirstSampleAcceptance.Write();
        ROIMaxPulses.Write();
        PixelMaxPulses.Write();
        ThresholdPosPixelPeaks.Write();
        Transparency.Write();
        PixelPulseWidths.Write();
        ROIPulseWidths.Write();
        HitCandidates.Write();
        Results.Close();

}

void PixLArReco::find2dHits(
            const TH2S &t_histo,
            std::vector<Hit2d> &t_hits,
            std::multimap<unsigned, unsigned> &t_hitOrderLead,
            std::multimap<unsigned, unsigned> &t_hitOrderTrail,
            unsigned &t_nMissed,
            const bool t_bipolar,
            const double t_discSigmaPosLead,
            const double t_discSigmaPosPeak,
            const double t_discAbsPosPeak,
            const double t_discSigmaPosTrail,
            const double t_discSigmaNegLead,
            const double t_discSigmaNegPeak,
            const double t_discAbsNegPeak,
            const double t_discSigmaNegTrail)
{
        // Clear the hit vector and maps from potential old data.
        t_hits.clear();
        t_hitOrderLead.clear();
        t_hitOrderTrail.clear();

        // Index of the hits vector needed for the ordered maps.
        unsigned hitId = 0;

        // Loop over all channels of the input histo.
        // Pay attention to bin numbers!!! Loops (and everything else) start at 0, histos start at 1!!!
        for (unsigned channel = 0; channel < t_histo.GetNbinsY(); ++channel) {
                // Get the histo of a single channel using the ProjectionX method of TH2.
                auto channelHisto = std::shared_ptr<TH1D>(
                    t_histo.ProjectionX("channelHisto", (channel + 1), (channel + 1)));
                std::pair<double, double> noiseParams = NoiseFilter::computeNoiseParams(channelHisto, true);
                //if (noiseParams.first < 1.) {
                //    noiseParams.first = 1.;
                //}
                double noiseBaseline    = noiseParams.first;
                double thrPosLead	= noiseParams.first + t_discSigmaPosLead * noiseParams.second;
                double thrPosPeak	= noiseParams.first + std::max(t_discSigmaPosPeak * noiseParams.second, t_discAbsPosPeak);
                double thrPosTrail	= noiseParams.first + t_discSigmaPosTrail * noiseParams.second;
                //double thrNegLead	  = noiseParams.first - t_discSigmaNegLead * noiseParams.second;
                double thrNegPeak	= noiseParams.first - std::max(t_discSigmaNegPeak * noiseParams.second, t_discAbsNegPeak);
                double thrNegTrail	= noiseParams.first - t_discSigmaNegTrail * noiseParams.second;
                // std::cout << "noiseBaseline " << noiseBaseline << std::endl;
                //std::cout << "thrPosLead " << thrPosLead << std::endl;
                //std::cout << "thrPosPeak " << thrPosPeak << std::endl;
                //std::cout << "thrPosTrail " << thrPosTrail << std::endl;
                //std::cout << "thrNegPeak " << thrNegPeak << std::endl;
                //std::cout << "thrNegTrail " << thrNegTrail << std::endl;
                unsigned posPeakSample = static_cast<unsigned>(channelHisto->GetMaximumBin()) - 1;
                int posPeakValue = static_cast<int>(channelHisto->GetBinContent(posPeakSample + 1));
                if(posPeakValue < thrPosPeak){
                        std::cout << "Didn't meet threshold!!!!\n";
                }
                // Find all hits in this channel
                while (posPeakValue >= thrPosPeak) {
                        // Start and end of the pulse.
                        int firstSample;
                        int zeroCrossSample;
                        int negPeakSample;
                        int negPeakValue = 0;
                        int lastSample;
                        bool foundFirstSample = false;
                        bool foundZeroCrossSample = false;
                        // Loop to find the first/last sample of the pulse using constant fraction discrimination.
                        // We only search in the specified range.
                        for (int sampleOffset = 1; sampleOffset <= m_runParams.getDiscRange(); ++sampleOffset) {
                                // First sample. Only look if we haven't found it yet.
                                if (!foundFirstSample) {
                                        firstSample = posPeakSample - sampleOffset;
                                        // Check whether we've crossed the constant fraction threshold.
                                        if ((firstSample >= 0) && (channelHisto->GetBinContent(firstSample + 1) < thrPosLead)) {
                                                foundFirstSample = true;
                                        }

                                }
                                // Last sample. Only look if we haven't found it yet.
                                if (!foundLastSample) {
                                        lastSample = posPeakSample + sampleOffset;
                                        // Check whether we've crossed the constant fraction threshold.
                                        if ((lastSample < channelHisto->GetNbinsX()) && (channelHisto->GetBinContent(lastSample + 1) < thrPosTrail)) {
                                                foundLastSample = true;
                                        }
                                }
                        }
                        if (t_bipolar && foundLastSample) {
                                foundLastSample = false;
                                for (int sample = lastSample; (sample <= (posPeakSample + 3 * m_runParams.getDiscRange())) && (sample < channelHisto->GetNbinsX()); ++sample) {
                                        int binContent = static_cast<int>(channelHisto->GetBinContent(sample + 1));
                                        if (!foundZeroCrossSample) {
                                                if (binContent < noiseBaseline) {
                                                        zeroCrossSample = sample;
                                                        foundZeroCrossSample = true;
                                                }
                                        } else if (!crossedThrNegPeak) {
                                                if (binContent <= thrNegPeak) {
                                                        crossedThrNegPeak = true;
                                                }
                                               }
                                               // Last sample. Only look if we haven't found it yet.
                                               if (!foundLastSample) {
                                                        lastSample = sample;
                                                        // Check whether we've crossed the constant fraction threshold.
                                                        if (crossedThrNegPeak && (binContent > thrNegTrail)) {
                                                                foundLastSample = true;
                                                        } else if (binContent < negPeakValue) {
                                                                negPeakSample = sample;
                                                                negPeakValue = binContent;
                                                                }
                                                        }
                                                }
                                        }
                                        // If we detected both the rising and the falling edge, build a 2D hit.
                                        if (foundFirstSample && foundLastSample) {
                                                Hit2d hit;
                                                hit.channel = channel;
                                                hit.firstSample = static_cast<unsigned>(firstSample);
                                                hit.lastSample = static_cast<unsigned>(lastSample);
                                                hit.posPeakSample = posPeakSample;
                                                hit.posPulseHeight = posPeakValue;
                                                if (t_bipolar) {
                                                        hit.zeroCrossSample = static_cast<unsigned>(zeroCrossSample);
                                                        hit.negPeakSample = static_cast<unsigned>(negPeakSample);
                                                        hit.negPulseHeight = negPeakValue;
                                                        hit.posPulseWidth = hit.zeroCrossSample - hit.firstSample;
                                                        hit.negPulseWidth = hit.lastSample - hit.zeroCrossSample + 1;
                                                        posPulseROIMax.push_back(posPeakValue);
                                                        roiWidthsVec.push_back(hit.posPulseWidth + hit.negPulseWidth);
                                                } else {
                                                        hit.zeroCrossSample = 0;
                                                        hit.negPeakSample = 0;
                                                        hit.negPulseHeight = 0;
                                                        hit.posPulseWidth = hit.lastSample - hit.firstSample + 1;
                                                        hit.negPulseWidth = 0;
                                                        posPulsePixelMax.push_back(posPeakValue);
                                                        thrPosPeakVec.push_back(thrPosPeak);
                                                        pixelWidthsVec.push_back(hit.posPulseWidth);
                                                        // std::cout << " posPulseWidth " << hit.posPulseWidth << std::endl;
                                                }
                                                hit.pulseIntegral = 0;
                                                hit.pulseRaw.clear();
                                                hit.pulseRaw.resize(hit.posPulseWidth + hit.negPulseWidth);
                                                // Raw pulse data vector iterator.
                                                auto pulseRaw = hit.pulseRaw.begin();
                                                // Loop over all pulse samples to store and integrate them.
                                                for (unsigned sample = hit.firstSample; sample <= hit.lastSample; ++sample) {
                                                        const int pulseData = static_cast<int>(channelHisto->GetBinContent(sample + 1));
                                                        hit.pulseIntegral += pulseData;
                                                        *pulseRaw = pulseData;
                                                        // Increment the raw pulse data vector iterator.
                                                        ++pulseRaw;
                                                }
                                                // Push the hit to the hits vector.
                                                t_hits.push_back(hit);
                                                // Insert the hit ID into the hit order maps. The key is the sample where the signal rises/falls
                                                // above/below the constant fraction.
                                                t_hitOrderLead.insert(std::pair<unsigned, unsigned>(firstSample, hitId));
                                                t_hitOrderTrail.insert(std::pair<unsigned, unsigned>(lastSample, hitId));
                                                // Increment the hit ID.
                                                ++hitId;
                                        } else {
                                                ++t_nMissed;
                                        }
                                        if (firstSample < 0) {
                                                firstSample = 0;
                                        }
                                        if (lastSample >= channelHisto->GetNbinsX()) {
                                                lastSample = channelHisto->GetNbinsX() - 1;
                                        }
                                        for (unsigned sample = firstSample; sample <= lastSample; ++sample) {
                                                channelHisto->SetBinContent((sample + 1), noiseBaseline);
                                        }
                                        posPeakSample = static_cast<unsigned>(channelHisto->GetMaximumBin()) - 1;
                                        posPeakValue = static_cast<int>(channelHisto->GetBinContent(posPeakSample + 1));
                                }
                        }
                }
        }
}

void PixLArReco::find3dHits(Event &t_event) {
        // Clear the match vectors from potential old data.
        t_event.pixel2roi.clear();
        t_event.roi2pixel.clear();
        // Preallocate the match vectors.
        t_event.pixel2roi.resize(t_event.pixelHits.size());
        t_event.roi2pixel.resize(t_event.roiHits.size());
        // Loop through ROI hits, sorted by rising pulse edge.
        // Starts at the first ROI pulse seen, loops according to time seen
        for (const auto &roiHitOrderEntry : t_event.roiHitOrderLead) {
            // Get the ROI hit ID from the map entry.
            const unsigned roiHitId = roiHitOrderEntry.second;
            // Loop over pixel hits, sorted by falling pulse edge.
            // First loop over all pixel hits falling in between the risng and the falling edge of the current ROI hit.
            for (auto pixelHitOrderEntry = t_event.pixelHitOrderTrail.lower_bound(
                    t_event.roiHits.at(roiHitId).firstSample);
                 pixelHitOrderEntry != t_event.pixelHitOrderTrail.upper_bound(t_event.roiHits.at(roiHitId).lastSample);
                 ++pixelHitOrderEntry) {
                // Get the pixel hit ID from the map entry.
                const unsigned pixelHitId = pixelHitOrderEntry->second;
                // Append matches to the match vectors.
                // Because we're currently inside the ROI pulse, we're sure this is an actual match.
                t_event.pixel2roi.at(pixelHitId).push_back(roiHitId);
                t_event.roi2pixel.at(roiHitId).push_back(pixelHitId);
                double transparency = (100.0*t_event.pixelHits.at(pixelHitId).pulseIntegral)/(t_event.pixelHits.at(pixelHitId).pulseIntegral +                          t_event.roiHits.at(roiHitId).pulseIntegral);
                transparencyVec.push_back(transparency);
                timePeakAcceptance.push_back(t_event.pixelHits.at(pixelHitId).posPeakSample - t_event.roiHits.at(roiHitId).posPeakSample);
                timeFirstSampleAcceptance.push_back(t_event.pixelHits.at(pixelHitId).firstSample - t_event.roiHits.at(roiHitId).firstSample);
            }
            // Now loop from the end of the ROI pulse until twice the peak finding range m_discRange after the end of the
            // pulse. This is the maximum length a pixel pulse can have. Thus, outside this range, a match to this ROI hit
            // is not possible.
            for (auto pixelHitOrderEntry = t_event.pixelHitOrderTrail.lower_bound(
                    t_event.roiHits.at(roiHitId).lastSample);
                 pixelHitOrderEntry !=
                 t_event.pixelHitOrderTrail.upper_bound(t_event.roiHits.at(roiHitId).lastSample + 2 * m_runParams.getDiscRange());
                 ++pixelHitOrderEntry) {
                // Get the pixel hit ID from the map entry.
                const unsigned pixelHitId = pixelHitOrderEntry->second;
                // Because we're no longer inside the ROI pulse, we need to check whether there's an actual overlap between
                // the pixel pulse and the ROI pulse.
                if (t_event.pixelHits.at(pixelHitId).firstSample <= t_event.roiHits.at(roiHitId).lastSample) {
                    // If they actually overlap, append the match to the match vectors.
                    t_event.pixel2roi.at(pixelHitId).push_back(roiHitId);
                    t_event.roi2pixel.at(roiHitId).push_back(pixelHitId);
                    timePeakAcceptance.push_back(t_event.pixelHits.at(pixelHitId).posPeakSample - t_event.roiHits.at(roiHitId).posPeakSample);
                    timeFirstSampleAcceptance.push_back(t_event.pixelHits.at(pixelHitId).firstSample - t_event.roiHits.at(roiHitId).firstSample);
                }
            }
        }
    }


void PixLArReco::buildHitCandidates(Event &t_event) {
        // Clear the hit candidate vector from potential old data.
        t_event.hitCandidates.clear();
        // Preallocate the hit candidate vector.
        t_event.hitCandidates.resize(t_event.pixelHits.size());
        // Pixel hits vector const iterator.
        auto pixelHit = t_event.pixelHits.cbegin();
        unsigned pixelHitId = 0;
        // Hit candidates vector iterator.
        auto hitCandidate = t_event.hitCandidates.begin();
        // Loop over all pixel hits in the pixel to ROI map.
        for (const auto &candidateRoiHitIds : t_event.pixel2roi) {
            // Get the pixel ID from the pixel hits vector.
            const unsigned pixelId = pixelHit->channel;
            // Check for duplicate 3dHits
            std::set<unsigned> roiIds;
            // Loop over all ROI hit IDs matched to the current pixel hit.
            for (const auto &candidateRoiHitId : candidateRoiHitIds) {
                // Get the ROI ID from the roi hits vector of the event using the ROI hit ID from the pixel to ROI map.
                const unsigned roiId = t_event.roiHits.at(candidateRoiHitId).channel;
                if (roiIds.find(roiId) != roiIds.cend()) {
                    continue;
                }
                roiIds.insert(roiId);
                // Build the 3D hit using the coordinates and calibration constants from the RunParams.
                Hit3d hit;
                // Calculate x,y,z in the units of pixel pitch and drift speed times drift time.
                // Origin in the center.
                hit.x = static_cast<float>((m_runParams.getRoiCoor(roiId, 0) + m_runParams.getPixelCoor(pixelId, 0))
                                           * m_runParams.getPixelPitch() + m_runParams.getTpcOrigin().at(0));
                hit.y = static_cast<float>((m_runParams.getRoiCoor(roiId, 1) + m_runParams.getPixelCoor(pixelId, 1))
                                           * m_runParams.getPixelPitch() + m_runParams.getTpcOrigin().at(1));
                hit.z = static_cast<float>(m_runParams.getDriftLength() / 2. + m_runParams.getTpcOrigin().at(2)
                                           - (pixelHit->posPeakSample - m_runParams.getAnodeSample())
                                             * m_runParams.getSampleTime() * m_runParams.getDriftSpeed());
                // Calculate charge in C.
                hit.charge = static_cast<float>(pixelHit->pulseIntegral *
                                                (m_runParams.getAdcLsb() / m_runParams.getPreampGain()));
                hit.pixelHitId = pixelHitId;
                hit.roiHitId = candidateRoiHitId;
                hitCandidate->push_back(hit);
            }
            // Increment the pixel hits and 3D hit candidates vector iterators.
            ++pixelHit;
            ++pixelHitId;
            ++hitCandidate;
        }
    }


  
void PixLArReco::beginJob()
{
}

void PixLArReco::beginRun(art::Run & r)
{
}

void PixLArReco::beginSubRun(art::SubRun & sr)
{
}

void PixLArReco::endJob()
{
}

void PixLArReco::endRun(art::Run & r)
{
}

void PixLArReco::endSubRun(art::SubRun & sr)
{
}

DEFINE_ART_MODULE(PixLArReco)
